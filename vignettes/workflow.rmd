---
title: "Long-read methylation data analysis with NanoMethViz and Bioconductor"
author: "Shian Su^[su.s@wehi.edu.au]"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{DifferentialMethylationWorkshop}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, cache = FALSE, include = FALSE}
knitr::opts_chunk$set(message = FALSE)
set.seed(1234)
```

```{r, cache = FALSE}
library(dmrseq)
library(tidyverse)
library(plyranges)
library(NanoMethViz)
```

# Introduction

DNA methylation is a key epigenetic regulator of gene expression in mammals, it involves the addition of a methyl group to the 5' position of cytosine residues in CpG dinucleotides. The methylation state of CpG sites can be influenced by a variety of factors, including environmental exposures, aging, and disease; it plays a crucial role in the regulation of gene expression, genomic imprinting, and X-chromosome inactivation. The methylation status of CpG sites can be measured using a variety of methods, including bisulfite sequencing, methylation arrays, and nanopore sequencing.

Oxford Nanopore Technologies (ONT) provides a commercial platform for nanopore long-read sequencing, a third-generation sequencing technology that produces high-throughput long-read sequencing data. By using direct-DNA sequencing without PCR amplification, ONT sequencing is able to sequence DNA molecules with all their modifications intact, including DNA methylation. This is in contrast to previous sequencing technologies which required bisulfite conversion to detect DNA methylation, which has more complex chemical treatments that may introduce bias.

In this workflow, we will demonstrate how to use the `NanoMethViz` package to analyze methylation data generated by ONT long-read sequencing. The `NanoMethViz` package provides a suite of tools for analyzing and visualizing methylation data generated by ONT sequencing, including functions for loading in methylation data, visualizing methylation patterns, and exporting data for identifying differentially methylated regions (DMRs) using other Bioconductor software such as bsseq, DSS, dmrseq and edgeR.

Before we move on, if you do not already have the input data, please download it by running the code below. This will download the modbam files that will serve as the raw data for this workshop. The data will be stored in the `input` directory.

```{r}
if (!dir.exists("input")) {
    options(timeout = 600)
    download.file("https://zenodo.org/records/12747551/files/input.tar.gz?download=1", "input.tar.gz")
    utils::untar("input.tar.gz")
    file.remove("input.tar.gz")
}
```

# Experimental Setup

The data we will be working with comes from the neural stem cells of triplicate female mice. The mice were F1 crosses between an Xist KO 129S1 female and CAST male, the resulting offspring have sufficiently different parental chromosomes to allow effective genome-wide haplotyping to distinguish the parent-of-origin for long-reads, allowing for the identification of genes that are imprinted or strain-specific. The Xist KO of the maternal genome also guarantees that X-inactivation takes place on the paternal X chromosome, allowing for the study of X-inactivation. Using Oxford Nanopore Technology's long-read direct DNA sequencing platform allows for DNA modification information to be captured and here we use it to study 5mC methylation in the mouse genome. For this workshop we will only use a subset of the data focusing on chromosome 7.

```{r}
knitr::include_graphics("img/MouseDesign.png")
```

# Loading in data

modBAM files are BAM files containing reads with additional tags on each read storing information about methylation probabilities at sites of interest, this is the currently preferred output of Dorado, the primary methylation caller offered by ONT. To use this data in `NanoMethViz` we must construct an object of the `ModBamResults` class. The `ModBamResults` class is a container for storing methylation data from multiple samples, along with sample annotation and exon annotation. To create this object we need to provide paths to the modBAM files, a sample table, and optionally exon annotation.

```{r}
knitr::include_graphics("img/ModBamResult.png")
```

```{r}
# List the modBAM files by searching for files with the .bam extension in the input directory
bam_files <- dir("input", pattern = "*bam$", full.names = TRUE)
bam_files
```

The samples need to be annotated with information for `NanoMethViz` to use in aggregating data within experimental groups. The sample table must contain `sample` and `group` columns with optional additional columns for further annotation. The rows of this table must match the order of the input files. The `group` column is generally the default grouping column used in the `NanoMethViz` package. In this example, we have grouped our data by haplotype.

```{r}
samples <- read_tsv("input/sample_anno.tsv", show_col_types = FALSE)
samples
```

Optionally we can add exon annotation to the object to generate tracks for gene annotation when plotting genomic regions/genes. The exon annotation must be a `data.frame` with columns `gene_id`, `chr`, `strand`, `start`, `end`, `transcript_id`, and `symbol`. A number of helper functions are provided to retrieve exon annotations in the correct format for human (hg19, hg38) and mouse (mm10, GRCm39). In this example, we will use the `get_exons_mm10` function to retrieve exon annotations for the mouse genome (mm10) and filter for chromosome 7.

```{r}
exon_anno <- get_exons_mm10() %>%
    filter(chr == "chr7")
exon_anno
```

Once we have created the `ModBamResult` object, we can use the `plot_gene()` function to visualize the methylation patterns of a gene of interest. In this example, we will plot the methylation patterns of the *Peg3* gene on chromosome 7 which is known to be imprinted in mice. The plot contains a smoothed trend line of the group-aggregated methylation levels across the gene body, along with a heatmap showing the methylation levels of individual CpG sites in each sample, and a track showing the isoforms of the gene if exon annotation is provided.

```{r}
mbr <- ModBamResult(
    methy = ModBamFiles(
        paths = bam_files,
        samples = samples$sample
    ),
    samples = samples,
    exons = exon_anno,
    mod_code = "m"
)

plot_gene(mbr, "Peg3")
```

The *Peg3* (paternally expressed gene 3) gene is known to be imprinted in mice, with the paternal allele being expressed and the maternal allele being silenced. In the plot, we see that there is a strong demthylation pattern on the paternal allele near the transcription start site (TSS) of the gene, allowing the gene to be expressed. The maternal allele is hypermethylated near the TSS, silencing the gene. This is a typical methylation pattern for an imprinted gene, and consistent with paternal expression of *Peg3*.

# Genome-wide analysis

While it is possible to use modBAM files to analyse specific regions of interest, genome-wide analysis requires the data to be in a tabix-indexed TSV file as it is easier to parse at scale. We can convert the modBAM files to a tabix-indexed TSV file using the `modbam_to_tabix()` function. This function will create a tabix-indexed TSV file containing the methylation data from the modBAM files. This file can then be used as input to the `NanoMethViz` functions that require sorted genomic data. In this example, we will convert the `ModBamResult` object to a tabix-indexed TSV file and save it to the `data` directory. We will use a pre-generated file in the interest of time, but you can run the code below to generate the file.

```{r, warn = FALSE}
dir.create("data", showWarnings = FALSE)
if (!file.exists("data/methy.tsv.bgz")) {
    modbam_to_tabix(mbr, "data/methy.tsv.bgz")
}
```

Once we have the tabix-indexed TSV file, we can create a `NanoMethResult` object using the `NanoMethResult` function. The `NanoMethResult` object contains the same information as the `ModBamResult` object but with the methylation data stored in a tabix-indexed TSV file. To create this object we need to provide paths to the tabix-indexed TSV file, along with the accompanying information we generated before.

```{r}
nmr <- NanoMethResult(
    methy = "data/methy.tsv.bgz",
    samples = samples,
    exons = exon_anno
)
```

The `NanoMethResult` object behaves in the same way as `ModBamResult` for any plotting functions. For example we can use `plot_gene()` to visualize the methylation patterns of the *Peg3* gene in exactly the same way but replacing the `ModBamResult` object with the `NanoMethResult` object. We should see the exact same plot as before.

```{r}
plot_gene(nmr, "Peg3")
```

`NanoMethViz` is primarily designed for visualising methylation data, in order to perform differential methylation analysis we can use other Bioconductor packages that implement sophisticated statistical procedures, such as `dmrseq`. To use the `dmrseq` function to identify DMRs between the two groups in our data, the `dmrseq` function requires a `BSseq` object as input, so we convert the `NanoMethResult` object to a `BSseq` object using the `methy_to_bsseq` function. Additionally we filter out regions with low coverage which are generally not informative for differential methylation analysis, here we remove any sites that are zero in all of the samples of either experimental group. The `BSSeq` object stores the methylation data as two matrices, the methylation matrix and the coverage matrix, with the option to store additional information such as sample annotation and genomic regions.

This conversion process usually takes some time, so we will load a pre-generated `BSSeq` object, the code used to generate the object is provided below.

```{r}
if (!file.exists("data/bss.rds")) {
    bss <- methy_to_bsseq(nmr)
    saveRDS(bss, "data/bss.rds")
} else {
    bss <- readRDS("data/bss.rds")
}

pat_cols <- str_detect(colnames(getCoverage(bss)), "pat")
mat_cols <- str_detect(colnames(getCoverage(bss)), "mat")

low_cov <- (rowSums(getCoverage(bss)[, pat_cols] == 0) == 3) |
           (rowSums(getCoverage(bss)[, mat_cols] == 0) == 3)

table(low_cov)/sum(table(low_cov))

bss <- bss[!low_cov, ]
```

# MDS Plot

Using the `BSSeq` object we are able to create a multi-dimensional scaling (MDS) plot to visualize the methylation patterns of the samples, a method commonly used in differential gene expression analysis. Since `BSSeq` objects store the methylation data as two matrices, the methylation matrix and the coverage matrix, we need to convert the `BSSeq` object such that each CpG site from each sample is represented by a single value in a matrix. This can be done using the `bsseq_to_log_methy_ratio` function which converts the `BSSeq` object to a matrix of the log of the methylation ratio with a small count added to prevent division by zero. The `plot_mds` function can then be used to create an MDS plot of the samples using the log methylation ratio matrix as input. The samples are colored by group, in this case, maternal and paternal.

Because the number of CpG sites is large, we accumulate the methylation data over genes to both reduce the size of the data but also produce a more stable measure of methylation. This is done by providing the `regions = exons_to_genes(exons(nmr))` argument to `bsseq_to_log_methy_ratio` which will aggregate the methylation data over genes. Without the argument, the function will use individual CpG sites. After the data is aggregated, `plot_mds` uses only the top 500 most variable features to create the MDS plot.

```{r}
cgi_anno <- get_cgi_mm10() %>%
    filter(chr == "chr7")

cgi_anno

lmr <- bsseq_to_log_methy_ratio(
    bss,
    regions = cgi_anno
)

groups <- colnames(lmr) %>%
    str_extract("mat|pat")

plot_mds(lmr, groups = groups)
```

From this MDS we see that there is not a clear separation between the maternal and paternal groups, suggesting that there is no strong global difference in methylation patterns between the two groups, and that we don't expect to find many differentially methylated regions between the two groups. This is mostly expected as imprinted genes are rare in mice and most genes in the autosomes should behave similarly between the two parental alleles.

# Aggregating feature methylation data

It is often informative to aggregate methylation data over a class of features to identify broad patterns of methylation across the features. This can help establish overall differences in methylation patterns between groups in a class of features such as genes, CpG islands, or enhancers. The `NanoMethViz` package provides a functions for aggregating methylation data across genomic regions. The `plot_agg_regions()` function can be used to visualize the aggregated methylation data across a set of features of interest defined by a table of coordinates. For example we may want to investigate the methylation patterns of a set of genes on chromosome 7. We can use the `exons_to_genes()` helper function to convert exon annotations already stored in the object to gene annotations and filter for only chromosome 7 genes. Then, for speed, we can subset 100 regions and use the `plot_agg_regions()` function to visualize the mean methylation profile across those genes. With more time we could use the full set of genes.

```{r}
gene_anno <- exons_to_genes(exons(nmr))
plot_agg_regions(nmr, regions = slice_sample(gene_anno, n = 100), group_col = "group")
```

In this plot we can see that active genes tend to be demethylated near the TSS region and hypermethylated throughout the genebody. This is consistent with the proposed function of methylation in gene regulation, where methylation in promoter region of genes is associated with gene silencing, while transcription of active genes is associated with recruitment of methylating mechanisms to the genebody.

Another class of features of interest are CpG islands, which are regions of the genome that are rich in CpG dinucleotides. CpG islands are often associated with gene promoters and are generally unmethylated in normal cells. We can use the `get_cgi_mm10()` function to retrieve CpG island annotations for the mouse genome (mm10) and filter for chromosome 7. We can then use the `plot_agg_regions()` function to visualize the mean methylation profile across CpG islands on chromosome 7. We expect to see a clear pattern of demethylation over CpG islands, which tend to be enriched in the promoter regions of genes.

```{r}
plot_agg_regions(nmr, cgi_anno, group_col = "group")
```

# Differential methylation

Another common analysis is to identify differentially methylated regions (DMRs) between the experimental groups. It is generally more informative to identify DMRs rather than individual CpG sites, as DMRs are more likely to be functionally relevant and biologically interpretable. However DMRs are not easy to identify, as it requires the identification of individual significant sites, some determination of whether nearby sites should be aggregated into a region, and a statistical test to determine if the region as a whole is differentially methylated.

The `dmrseq` package can be used to identify differentially methylated regions (DMRs) between the two groups in our data. The `dmrseq` function from the package requires a `BSseq` object as input, along with the name of the covariate to test for differential methylation. We will test for differential methylation between the maternal and paternal groups. The `dmrseq` function returns a `GRanges` object containing the DMRs identified by the function. The `GRanges` object contains the genomic coordinates of the DMRs, along with information about the statistical significance of the DMRs.

There are alternatives to `dmrseq` for identifying DMRs, such as `bsseq`, `DSS` and `edgeR`. For `bsseq` and `DSS` the same `BSSeq` object can be used as input, while for `edgeR` the `BSSeq` object must be further converted to a `DGEList` object using the `bsseq_to_edger()` or `methy_to_edger()` functions. `bsseq`, `DSS` and `dmrseq` all use a similar approach to identify DMRs, using a statistical test to compare the methylation levels between the two groups at each CpG site, followed by a clustering step to identify regions of the genome with consistent differences in methylation levels for de novo DMR discovery. While `edgeR` requires users to choose the regions to test for differential methylation, which is reflected by the regions in which they choose to summarise counts. `dmrseq` and `edgeR` are able to produce p-values for each region while `bsseq` and `DSS` only provide p-values for each CpG site along with an aggregated area statistic.

```{r}
pData(bss)$condition <- NanoMethViz::samples(nmr)$group

if (!file.exists("data/regions")) {
    regions <- dmrseq(bss, testCovariate = "condition", minNumRegion = 20)
    saveRDS(regions, "data/regions.rds")
} else {
    regions <- readRDS("data/regions.rds")
}
```

A number of regions will be produced by `dmrseq`, this includes regions were aggregated because they contained significant CpG sites but failed to reach statistical significance at a region level. In order to make sense of these results, we generally want to associate the regions to genes. One way to do that is to use the `plyranges` object along with the the gene annotation we already generated. We want to find DMR regions that overlap within a certain distance of the transcription start site (TSS) of a gene. We use `anchor_5p()` and `mutate(width = 1)` to shrink the annotation to the TSS site, then we stretch the annotation by 10kb such that it spans 5kb on either side of the TSS. We then use the `join_overlap_intersect()` function to find the DMRs that are near a gene's TSS. This will return a `GRanges` object containing the DMRs which overlap with the gene TSS regions, and append information about the gene to the DMRs.

```{r}
gene_anno_gr <- as_granges(dplyr::rename(gene_anno, seqnames = "chr"))

gene_anno_gr_tss <- gene_anno_gr %>%
    anchor_5p() %>%
    mutate(width = 1) %>%
    stretch(10000)

gene_dmr_overlaps <- join_overlap_intersect(regions, gene_anno_gr_tss)
gene_dmr_overlaps
```

After we identify the DMRs that overlap with the gene TSS regions, we can filter for the significant DMRs using the `qval` column. This is the adjusted p-value for the DMRs, calculated using the Benjamini-Hochberg procedure to control false-discovery rates for multiple-testing. We can then select the columns we are interested in, such as the gene symbol, chromosome, start and end positions of the DMRs, the strand of the gene, and the q-value of the DMRs.

```{r}
dmr_regions <- as_tibble(gene_dmr_overlaps) %>%
    dplyr::rename(chr = "seqnames")

signif_regions <- dmr_regions %>%
    filter(qval < 0.05)

signif_regions %>%
    select(symbol, chr, start, end, strand, qval)
```

We see that some DMRs overlap with multiple genes, and here we can plot the methylations of genes *Peg3* and *Kcnq1ot1* which are known to be imprinted in mice with the significant regions highlighted using `plot_gene()` with the `anno_regions` argument set to the regions we identified. This will highlight the significant regions in the gene plot in a shaded band. We can then see in both these genes, as required by our filtering criteria, the differentially methylated regions fall near the TSS of the genes.

```{r}
options("NanoMethViz.highlight_col" = "green")
plot_gene(nmr, "Peg3", anno_regions = signif_regions)
plot_gene(nmr, "Kcnq1ot1", anno_regions = signif_regions)
plot_gene(nmr, "Cdkn1c", anno_regions = signif_regions)
```

We have now successfully used dmrseq to statistically identify differentially methylated regions around known imprinted genes. Additionally we have used that information to visualise the methylation data of the genes associated with the DMRs, and we see that it is primarily near the TSS where differential methylation occurs.

# Session Info

```{r}
sessionInfo()
```
